using NLog;
using System;
using System.Collections.Generic;
using System.IO;

using software_solution.logger;

namespace software_solution.controller
{
    static class FileWorks
    {
        private static readonly Logger logger = new LoggerType().GetLogger();

        /// <summary>
        /// Transform dicts of strings with positions and their values to csv plain text. One position at a time.
        /// Takes two separate dicts which represent data from two data grids. Introducts a gap between two parts,
        /// represented by additional esc seq. (\n)
        /// </summary>
        /// <param name="loadData">First source of positions</param>
        /// <param name="unloadData">Second source of positions</param>
        /// <returns>Combined string of all positions plain csv</returns>
        private static string TransformToCsv(Dictionary<string, int> loadData, Dictionary<string, int> unloadData)
        {
            string plainCsvLoad = "",
                   plainCsvUnload = "";

            foreach(var item in loadData) {
                plainCsvLoad = plainCsvLoad + item.Key + ";" + item.Value + ";\n";
            }
            foreach (var item in unloadData) {
                plainCsvUnload = plainCsvUnload + item.Key + ";" + item.Value + ";\n";
            }
            logger.Info($"Csv from loadData grid (unfolded): \n[\n{plainCsvLoad}]\n");
            logger.Info($"Csv from unloadData grid (unfolded): \n[\n{plainCsvUnload}]\n");

            /* CSV
             * { 
             * HEX;AMOUNT;  <- load data
             * HEX;AMOUNT:  <- load data
             *              <- split
             * HEX;AMOUNT;  <- unload data
             * HEX;AMOUNT;  <- unload data
             * }
             */
            return plainCsvLoad + "\n" + plainCsvUnload;
        }

        /// <summary>
        /// Transform plain csv text to actual items and loads them to according Dicts. Plain csv include a space which
        /// indicates whether the csv HEX;AMOUNT; goes to unload or load.
        /// </summary>
        /// <param name="plainCsv">Plain csv text to process</param>
        /// <param name="loadData">First dict for items to be added to</param>
        /// <param name="unloadData">Second dict for items to be added to</param>
        private static void TransformToDicts(string plainCsv, ref Dictionary<string, int> loadData, ref Dictionary<string, int> unloadData)
        {
            // load - true, unload - false
            bool loadUnloadFlag = true;

            var linesFromCsv = plainCsv.Split('\n');
            foreach (string csvLine in linesFromCsv)
            {
                // processes 'split' which changes csv destination
                if (csvLine == "") {
                    loadUnloadFlag = false;
                    continue;
                }
                logger.Info($"Csv line: [{csvLine}] goes to load - {loadUnloadFlag} -> OKAY");

                var cols = csvLine.Split(';');
                if (loadUnloadFlag)
                {
                    loadData.Add(cols[0], Convert.ToInt32(cols[1]));
                    logger.Info($"Csv added to load");
                }
                else
                {
                    unloadData.Add(cols[0], Convert.ToInt32(cols[1]));
                    logger.Info($"Csv added to unload");
                }
            }
        }

        /// <summary>
        /// Writes any data to file using SteamWriter. Mostly safe method, which implements try/catch and using. 
        /// Data must be in string plain text format.
        /// </summary>
        /// <param name="data">Data to write to file</param>
        /// <param name="filename">File name for data to be written in</param>
        private static void WriteToFile(string data, string filename)
        {
            try {
                using (StreamWriter writer = new StreamWriter(filename)) {
                    writer.Write(data);
                    logger.Info($"Data [{data}] goes to file: [{filename}] -> OKAY");
                }
            }
            catch (FileNotFoundException fnf) {
                logger.Error($"File not found at {filename}\n mesg: {fnf.Message}");
            }
            catch (Exception any)
            {
                logger.Error($"Unexpected error {filename}\n mesg: {any.Message}");
            }
        }

        /// <summary>
        /// Reads any data from file using StreamReader. Mostly safe method, which includes try/catch and using.
        /// Data should be in csv format. Since it was generated by this program it should work flawlessly.
        /// </summary>
        /// <param name="filename">Name of the file which contains needed text</param>
        /// <returns>Plain text data</returns>
        private static string ReadFromFile(string filename)
        {
            string plainText = "";

            try
            {
                using (StreamReader reader = new StreamReader(filename))
                {
                    string plainTextLine;

                    while ((plainTextLine = reader.ReadLine()) != null) 
                    {
                        plainText = plainText + plainTextLine + "\n";
                        logger.Info($"Line of data from file: [{plainTextLine}]");
                    }
                }
            }
            catch (FileNotFoundException fnf)
            {
                logger.Error($"File not found at {filename}\n mesg: {fnf.Message}");
            }
            catch (Exception any)
            {
                logger.Error($"Unexpected error {filename}\n mesg: {any.Message}");
            }

            return plainText;
        }

        // wrapper for TransformToCsv and WriteToFile functions
        public static void WriteCSV(Dictionary<string, int> loadData, Dictionary<string, int> unloadData, string filename)
        {
            var data = TransformToCsv(loadData, unloadData);
            WriteToFile(data, filename);
        }

        // wrapper for ReadFromFile and TransformToDicts functions, uses refs so to change the original dicts
        public static void ReadCSV(ref Dictionary<string, int> loadData, ref Dictionary<string, int> unloadData, string filename)
        {
            var plainCsv = ReadFromFile(filename);
            TransformToDicts(plainCsv, ref loadData, ref unloadData);
        }
    
    }
}
